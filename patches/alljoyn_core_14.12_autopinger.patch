diff --git a/alljoyn_core/inc/alljoyn/AutoPinger.h b/alljoyn_core/inc/alljoyn/AutoPinger.h
index dac88d5..f626a43 100644
--- a/alljoyn_core/inc/alljoyn/AutoPinger.h
+++ b/alljoyn_core/inc/alljoyn/AutoPinger.h
@@ -5,7 +5,7 @@
  */
 
 /******************************************************************************
- * Copyright (c) 2014, AllSeen Alliance. All rights reserved.
+ * Copyright (c) 2015, AllSeen Alliance. All rights reserved.
  *
  *    Permission to use, copy, modify, and/or distribute this software for any
  *    purpose with or without fee is hereby granted, provided that the above
@@ -28,9 +28,7 @@
 #endif
 
 #include <map>
-#include <qcc/Timer.h>
 #include <qcc/String.h>
-#include <qcc/Mutex.h>
 #include <qcc/Debug.h>
 #include <alljoyn/Status.h>
 #include <alljoyn/PingListener.h>
@@ -38,14 +36,14 @@
 namespace ajn {
 /// @cond ALLJOYN_DEV
 /** @internal Forward references */
+class AutoPingerInternal;
 class BusAttachment;
-struct PingGroup;
 /// @endcond
 
 /**
  * AutoPinger class
  */
-class AutoPinger : public qcc::AlarmListener {
+class AutoPinger {
   public:
 
 
@@ -61,7 +59,7 @@ class AutoPinger : public qcc::AlarmListener {
     /**
      * Destructor
      */
-    virtual ~AutoPinger();
+    ~AutoPinger();
 
     /**
      * Pause all ping actions
@@ -126,30 +124,11 @@ class AutoPinger : public qcc::AlarmListener {
     QStatus RemoveDestination(const qcc::String& group, const qcc::String& destination, bool removeAll = false);
 
   private:
-    friend class AutoPingAsyncCB;
-    friend struct Destination;
-    friend class PingAsyncContext;
-
-    enum PingState {
-        UNKNOWN,
-        LOST,
-        AVAILABLE
-    };
-
     AutoPinger(const AutoPinger&);
     void operator=(const AutoPinger&);
 
-    bool UpdatePingStateOfDestination(const qcc::String& group, const qcc::String& destination, const AutoPinger::PingState state);
-    void PingGroupDestinations(const qcc::String& group);
-    bool IsRunning();
-    void AlarmTriggered(const qcc::Alarm& alarm, QStatus reason);
-
-    qcc::Timer timer; /* Single Timerthread */
-    BusAttachment& busAttachment;
-    qcc::Mutex pingerMutex;
-    std::map<qcc::String, PingGroup*> pingGroups;
+    AutoPingerInternal*internal;
 
-    bool pausing;
 };
 static class AutoPingerInit {
   public:
@@ -160,5 +139,4 @@ static class AutoPingerInit {
     static bool cleanedup;
 } autoPingerInit;
 }
-#undef QCC_MODULE
 #endif /* AUTOPINGER_H_ */
diff --git a/alljoyn_core/src/AutoPinger.cc b/alljoyn_core/src/AutoPinger.cc
index 6c19077..db65402 100644
--- a/alljoyn_core/src/AutoPinger.cc
+++ b/alljoyn_core/src/AutoPinger.cc
@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright (c) 2014, AllSeen Alliance. All rights reserved.
+ * Copyright (c) 2014,2015, AllSeen Alliance. All rights reserved.
  *
  *    Permission to use, copy, modify, and/or distribute this software for any
  *    purpose with or without fee is hereby granted, provided that the above
@@ -13,150 +13,24 @@
  *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ******************************************************************************/
-
+#include "AutoPingerInternal.h"
 #include <alljoyn/AutoPinger.h>
-#include <alljoyn/BusAttachment.h>
-#include <qcc/time.h>
-#include <algorithm>
-#include <memory>
-#include <set>
-#include <cassert>
-
-#define QCC_MODULE "AUTOPINGER"
-#define PING_TIMEOUT 5000
 
 namespace ajn {
 
-// Destination data
-struct Destination {
-    Destination(const qcc::String& _destination, const AutoPinger::PingState _oldState) :
-        destination(_destination), oldState(_oldState) { }
-    qcc::String destination;
-
-    /* mutable so we can modify this even while iterating;
-     * see UpdatePingStateOfDestination()
-     */
-    mutable AutoPinger::PingState oldState;
-
-    bool operator==(const Destination& dest) const {
-        return (destination == dest.destination);
-    }
-
-    bool operator<(const Destination& dest) const {
-        return (destination < dest.destination);
-    }
-};
-
-// Group data
-struct PingGroup {
-    PingGroup(uint32_t pingInterval,      /* milliseconds */
-              qcc::AlarmListener* alarmListener,
-              void* context,
-              PingListener& _pingListener) :
-        alarm(pingInterval, alarmListener, context, pingInterval), pingListener(_pingListener) { }
-
-    ~PingGroup() {
-        qcc::String* ctx = static_cast<qcc::String*>(alarm->GetContext());
-        alarm->SetContext(NULL);
-        if (NULL != ctx) {
-            delete ctx;
-        }
-    }
-
-    qcc::Alarm alarm;
-    PingListener& pingListener;
-    std::map<Destination, unsigned int> destinations;
-};
-
-// Context used to pass additional info in callbacks
-class PingAsyncContext  {
-  public:
-    PingAsyncContext(AutoPinger* _pinger,
-                     const qcc::String& _group,
-                     const qcc::String& _destination,
-                     const AutoPinger::PingState _oldState,
-                     PingListener& listener) :
-        pinger(_pinger), group(_group), destination(_destination), oldState(_oldState), pingListener(listener)  { }
-
-    AutoPinger* pinger;
-    qcc::String group;
-    qcc::String destination;
-    AutoPinger::PingState oldState;
-    PingListener& pingListener;
-};
-
-static std::set<PingAsyncContext*>* ctxs = NULL;
-static qcc::Mutex* ctxMutex = NULL;
-
-// Callback handler for async pin calls
-class AutoPingAsyncCB : public BusAttachment::PingAsyncCB {
-  public:
-    void PingCB(QStatus status, void* context) {
-        PingAsyncContext* ctx = (PingAsyncContext*)context;
-
-        ctxMutex->Lock();
-        std::set<PingAsyncContext*>::iterator it = ctxs->find(ctx);
-
-        if (it != ctxs->end()) {
-            if ((ctx->pinger->IsRunning()) && (false == ctx->pinger->pausing)) {
-                if (ER_OK != status) {
-                    if (ER_ALLJOYN_PING_REPLY_IN_PROGRESS != status) {
-                        if (ctx->oldState != AutoPinger::LOST) {
-                            // update state
-                            if (true == (const_cast<AutoPinger*>(ctx->pinger))->UpdatePingStateOfDestination(ctx->group, ctx->destination, AutoPinger::LOST)) {
-
-                                // call external listener
-                                ctx->pingListener.DestinationLost(ctx->group, ctx->destination);
-                            }
-                        }
-                    }
-                } else {
-                    if (ctx->oldState != AutoPinger::AVAILABLE) {
-                        // update state
-                        if (true == ((ctx->pinger))->UpdatePingStateOfDestination(ctx->group, ctx->destination, AutoPinger::AVAILABLE)) {
-
-                            // call external listener
-                            ctx->pingListener.DestinationFound(ctx->group, ctx->destination);
-                        }
-                    }
-                }
-
-            } else {
-                QCC_DbgPrintf(("AutoPinger: ignoring callback - pinger not running"));
-            }
-            ctxs->erase(it);
-        } else {
-            QCC_DbgPrintf(("AutoPinger: ignoring callback - ping already gone"));
-        }
-
-        ctxMutex->Unlock();
-
-        delete ctx;
-    }
-};
-
-static AutoPingAsyncCB* pingCallback = NULL;
-
 static int autoPingerCounter = 0;
 bool AutoPingerInit::cleanedup = false;
 AutoPingerInit::AutoPingerInit()
 {
     if (autoPingerCounter++ == 0) {
-        ctxs = new std::set<PingAsyncContext*>();
-        ctxMutex = new qcc::Mutex();
-        pingCallback = new AutoPingAsyncCB();
+        AutoPingerInternal::Init();
     }
 }
 
 AutoPingerInit::~AutoPingerInit()
 {
     if (--autoPingerCounter == 0 && !cleanedup) {
-        delete ctxs;
-        ctxs = NULL;
-        delete ctxMutex;
-        ctxMutex = NULL;
-        delete pingCallback;
-        pingCallback = NULL;
+        AutoPingerInternal::Cleanup();
         cleanedup = true;
     }
 }
@@ -164,275 +38,54 @@ AutoPingerInit::~AutoPingerInit()
 void AutoPingerInit::Cleanup()
 {
     if (!cleanedup) {
-        delete ctxs;
-        ctxs = NULL;
-        delete ctxMutex;
-        ctxMutex = NULL;
-        delete pingCallback;
-        pingCallback = NULL;
+        AutoPingerInternal::Cleanup();
         cleanedup = true;
     }
 }
+
 AutoPinger::AutoPinger(ajn::BusAttachment& _busAttachment) :
-    timer("autopinger"), busAttachment(_busAttachment), pausing(false)
+    internal(new AutoPingerInternal(_busAttachment))
 {
-    QCC_DbgPrintf(("AutoPinger constructed"));
-    timer.Start();
 }
 
 AutoPinger::~AutoPinger()
 {
-    pausing = true;
-    timer.RemoveAlarmsWithListener(*this);
-
-    // Stop timer thread
-    if (timer.IsRunning()) {
-        timer.Stop();
-    }
-
-    // Wait for thread to finish up
-    timer.Join();
-
-    // Invalidate all ctx;
-    ctxMutex->Lock();
-    for (std::set<PingAsyncContext*>::iterator it = ctxs->begin(); it != ctxs->end();) {
-        if ((*it)->pinger == this) {
-            ctxs->erase(it++);
-        } else {
-            it++;
-        }
-    }
-    ctxMutex->Unlock();
-
-    // Cleanup all groups
-    pingerMutex.Lock();
-    for (std::map<qcc::String, PingGroup*>::iterator pair = pingGroups.begin(); pair != pingGroups.end(); ++pair) {
-        delete pair->second;
-    }
-    pingerMutex.Unlock();
-
-    QCC_DbgPrintf(("AutoPinger destructed"));
-}
-
-void AutoPinger::AlarmTriggered(const qcc::Alarm& alarm, QStatus reason)
-{
-    qcc::String* groupName(reinterpret_cast<qcc::String*>(alarm->GetContext()));
-
-    if ((false == pausing) && (NULL != groupName)) {
-        // Ping all destination of the group
-        PingGroupDestinations(*groupName);
-    }
-}
-
-void AutoPinger::PingGroupDestinations(const qcc::String& group)
-{
-    QCC_DbgPrintf(("AutoPinger: start pinging destination in group: '%s'", group.c_str()));
-    ctxMutex->Lock();
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::const_iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        std::map<Destination, unsigned int>::iterator mapIt = (*it).second->destinations.begin();
-        for (; mapIt != (*it).second->destinations.end(); ++mapIt) {
-            PingAsyncContext* context = new PingAsyncContext(this, group, mapIt->first.destination, mapIt->first.oldState, (*it).second->pingListener);
-            std::pair<std::set<PingAsyncContext*>::iterator, bool> pair = ctxs->insert(context);
-            if (ER_OK != busAttachment.PingAsync(mapIt->first.destination.c_str(), PING_TIMEOUT, pingCallback, context)) {
-                ctxs->erase(pair.first);
-                delete context;
-            }
-        }
-    }
-    pingerMutex.Unlock();
-    ctxMutex->Unlock();
+    delete internal;
 }
 
 void AutoPinger::Pause()
 {
-    // Stop all pending alarms
-    pausing = true;
-    timer.RemoveAlarmsWithListener(*this);
-
-    QCC_DbgPrintf(("AutoPinger paused"));
+    internal->Pause();
 }
 
 void AutoPinger::Resume()
 {
-    assert(timer.IsRunning());
-    if (true == pausing) {
-        pingerMutex.Lock();
-        // re-add all Alarm objects
-        std::map<qcc::String, PingGroup*>::const_iterator it = pingGroups.begin();
-        for (; it != pingGroups.end(); ++it) {
-            timer.AddAlarmNonBlocking((*it).second->alarm);
-        }
-        pingerMutex.Unlock();
-
-        pausing = false;
-        QCC_DbgPrintf(("AutoPinger resumed"));
-    }
+    internal->Resume();
 }
 
 void AutoPinger::AddPingGroup(const qcc::String& group, PingListener& listener, uint32_t pingInterval)
 {
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    uint32_t intervalMillisec = pingInterval * 1000;
-    if (it != pingGroups.end()) {
-        // Group already exists => just update its ping time
-        QCC_DbgPrintf(("AutoPinger: updating existing group: '%s' with new ping time: %u", group.c_str(), pingInterval));
-
-        if (timer.RemoveAlarm((*it).second->alarm, false)) {
-            // Cleanup old alarm
-            void* context = (*it).second->alarm->GetContext();
-            (*it).second->alarm->SetContext(NULL);
-            if (NULL == context) {
-                // There was no context, create one
-                context = (void*)(new qcc::String(group));
-            }
-
-            // Alarm is a managed object (auto cleanup when overwritten)
-            qcc::AlarmListener* alarmListener = (qcc::AlarmListener*)this;
-            (*it).second->alarm = qcc::Alarm(intervalMillisec, alarmListener, context, intervalMillisec);
-            timer.AddAlarmNonBlocking((*it).second->alarm);
-        }
-    } else {
-        // Create a new group element
-        QCC_DbgPrintf(("AutoPinger: adding new group: '%s' with ping time: %u", group.c_str(), pingInterval));
-
-        void* context = (void*)(new qcc::String(group));
-        PingGroup* pingGroup = new PingGroup(intervalMillisec, this, context, listener);
-        pingGroups.insert(std::pair<qcc::String, PingGroup*>(group, pingGroup));
-        timer.AddAlarmNonBlocking(pingGroup->alarm);
-    }
-    pingerMutex.Unlock();
+    internal->AddPingGroup(group, listener, pingInterval);
 }
 
 void AutoPinger::RemovePingGroup(const qcc::String& group)
 {
-    QCC_DbgPrintf(("AutoPinger: removing group: '%s'", group.c_str()));
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        // destructor of PingGroup cleans-up context
-        timer.RemoveAlarm((*it).second->alarm, false);
-        delete it->second;
-        pingGroups.erase(it);
-    }
-    pingerMutex.Unlock();
+    internal->RemovePingGroup(group);
 }
 
 QStatus AutoPinger::SetPingInterval(const qcc::String& group, uint32_t pingInterval)
 {
-    QStatus status = ER_FAIL;
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        QCC_DbgPrintf(("AutoPinger: updating group: '%s' with ping time: %u", group.c_str(), pingInterval));
-
-        if (timer.RemoveAlarm((*it).second->alarm, false)) {
-            // Cleanup old alarm
-            void* context = (*it).second->alarm->GetContext();
-            (*it).second->alarm->SetContext(NULL);
-            if (NULL == context) {
-                context = (void*)(new qcc::String(group));
-            }
-
-            // Alarm is a managed object (auto cleanup when overwritten)
-            uint32_t intervalMillisec = pingInterval * 1000;
-            qcc::AlarmListener* alarmListener = (qcc::AlarmListener*)this;
-            (*it).second->alarm = qcc::Alarm(intervalMillisec, alarmListener, context, intervalMillisec);
-            timer.AddAlarmNonBlocking((*it).second->alarm);
-
-            status = ER_OK;
-        }
-    } else {
-        status = ER_BUS_PING_GROUP_NOT_FOUND;
-        QCC_LogError(status, ("AutoPinger: cannot update ping time for non-existing group: '%s'", group.c_str()));
-    }
-    pingerMutex.Unlock();
-    return status;
+    return internal->SetPingInterval(group, pingInterval);
 }
 
 QStatus AutoPinger::AddDestination(const qcc::String& group, const qcc::String& destination)
 {
-    QStatus status = ER_FAIL;
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        status = ER_OK;
-        Destination dummy(destination, AutoPinger::UNKNOWN);
-        std::map<Destination, unsigned int>::iterator dit;
-        if ((dit = it->second->destinations.find(dummy)) == it->second->destinations.end()) {
-            QCC_DbgPrintf(("AutoPinger: adding destination: '%s' to group: %s", destination.c_str(), group.c_str()));
-            (*it).second->destinations[(Destination(destination, AutoPinger::UNKNOWN))] = 1;
-        } else {
-            dit->second++;
-            QCC_DbgPrintf(("AutoPinger: destination: '%s' already present in group: %u; increasing refcount", destination.c_str(), group.c_str()));
-        }
-    } else {
-        status = ER_BUS_PING_GROUP_NOT_FOUND;
-        QCC_LogError(status, ("AutoPinger: cannot add destination: '%s' to non-existing group: %u", destination.c_str(), group.c_str()));
-    }
-    pingerMutex.Unlock();
-
-    return status;
+    return internal->AddDestination(group, destination);
 }
 
 QStatus AutoPinger::RemoveDestination(const qcc::String& group, const qcc::String& destination, bool removeAll)
 {
-    QStatus status = ER_FAIL;
-    QCC_DbgPrintf(("AutoPinger: remove destination: '%s' from group: %s", destination.c_str(), group.c_str()));
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        status = ER_OK;
-        Destination dummy(destination, AutoPinger::UNKNOWN);
-        std::map<Destination, unsigned int>::iterator dit = it->second->destinations.find(dummy);
-        if (dit != it->second->destinations.end()) {
-            if (removeAll == true) {
-                dit->second = 0;
-            } else {
-                --dit->second;
-            }
-
-            if (dit->second == 0) {
-                it->second->destinations.erase(dit);
-            }
-        }
-    }
-    pingerMutex.Unlock();
-
-    return status;
-}
-
-bool AutoPinger::UpdatePingStateOfDestination(const qcc::String& group,
-                                              const qcc::String& destination,
-                                              const AutoPinger::PingState state)
-{
-    QCC_DbgPrintf(("AutoPinger: UpdatePingStateOfDestination: '%s' from group: %s", destination.c_str(), group.c_str()));
-    bool result = false;
-    pingerMutex.Lock();
-    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
-    if (it != pingGroups.end()) {
-        Destination dummy(destination, AutoPinger::UNKNOWN);
-        std::map<Destination, unsigned int>::iterator dit = it->second->destinations.find(dummy);
-
-        // Update state
-        if (dit != (*it).second->destinations.end()) {
-            if (state != dit->first.oldState) {
-                /* this only works because oldState is mutable.
-                   Alternatively, you have to add it again to the map (and erase the old one) */
-                dit->first.oldState = state;
-                result = true; /* state gets updated */
-            }
-        }
-    }
-    pingerMutex.Unlock();
-    return result;
-}
-
-bool AutoPinger::IsRunning()
-{
-    return timer.IsRunning();
+    return internal->RemoveDestination(group, destination, removeAll);
 }
 
 }
diff --git a/alljoyn_core/src/AutoPingerInternal.cc b/alljoyn_core/src/AutoPingerInternal.cc
new file mode 100644
index 0000000..d8198dd
--- /dev/null
+++ b/alljoyn_core/src/AutoPingerInternal.cc
@@ -0,0 +1,420 @@
+/******************************************************************************
+ * Copyright (c) 2015, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#include "AutoPingerInternal.h"
+#include <alljoyn/BusAttachment.h>
+#include <qcc/time.h>
+#include <algorithm>
+#include <memory>
+#include <set>
+#include <cassert>
+
+#define PING_TIMEOUT 5000
+
+#define QCC_MODULE "AUTOPINGER"
+
+namespace ajn {
+
+// Destination data
+struct Destination {
+    Destination(const qcc::String& _destination, const AutoPingerInternal::PingState _oldState) :
+        destination(_destination), oldState(_oldState) { }
+    qcc::String destination;
+
+    /* mutable so we can modify this even while iterating;
+     * see UpdatePingStateOfDestination()
+     */
+    mutable AutoPingerInternal::PingState oldState;
+
+    bool operator==(const Destination& dest) const {
+        return (destination == dest.destination);
+    }
+
+    bool operator<(const Destination& dest) const {
+        return (destination < dest.destination);
+    }
+};
+
+// Group data
+struct PingGroup {
+    PingGroup(uint32_t pingInterval,      /* milliseconds */
+              qcc::AlarmListener* alarmListener,
+              void* context,
+              PingListener& _pingListener) :
+        alarm(pingInterval, alarmListener, context, pingInterval), pingListener(_pingListener) { }
+
+    ~PingGroup() {
+        qcc::String* ctx = static_cast<qcc::String*>(alarm->GetContext());
+        alarm->SetContext(NULL);
+        if (NULL != ctx) {
+            delete ctx;
+        }
+    }
+
+    qcc::Alarm alarm;
+    PingListener& pingListener;
+    std::map<Destination, unsigned int> destinations;
+};
+
+// Context used to pass additional info in callbacks
+class PingAsyncContext  {
+  public:
+    PingAsyncContext(AutoPingerInternal* _pinger,
+                     const qcc::String& _group,
+                     const qcc::String& _destination,
+                     const AutoPingerInternal::PingState _oldState,
+                     PingListener& listener) :
+        pinger(_pinger), group(_group), destination(_destination), oldState(_oldState), pingListener(listener)  { }
+
+    AutoPingerInternal* pinger;
+    qcc::String group;
+    qcc::String destination;
+    AutoPingerInternal::PingState oldState;
+    PingListener& pingListener;
+};
+
+static std::set<PingAsyncContext*>* ctxs = NULL;
+static qcc::Mutex* ctxMutex = NULL;
+
+// Callback handler for async pin calls
+class AutoPingAsyncCB : public BusAttachment::PingAsyncCB {
+  public:
+    void PingCB(QStatus status, void* context) {
+        PingAsyncContext* ctx = (PingAsyncContext*)context;
+
+        ctxMutex->Lock();
+        std::set<PingAsyncContext*>::iterator it = ctxs->find(ctx);
+
+        if (it != ctxs->end()) {
+            if ((ctx->pinger->IsRunning()) && (false == ctx->pinger->pausing)) {
+                if (ER_OK != status) {
+                    if (ER_ALLJOYN_PING_REPLY_IN_PROGRESS != status) {
+                        if (ctx->oldState != AutoPingerInternal::LOST) {
+                            // update state
+                            if (true == (const_cast<AutoPingerInternal*>(ctx->pinger))->UpdatePingStateOfDestination(ctx->group, ctx->destination, AutoPingerInternal::LOST)) {
+
+                                // call external listener
+                                ctx->pingListener.DestinationLost(ctx->group, ctx->destination);
+                            }
+                        }
+                    }
+                } else {
+                    if (ctx->oldState != AutoPingerInternal::AVAILABLE) {
+                        // update state
+                        if (true == ((ctx->pinger))->UpdatePingStateOfDestination(ctx->group, ctx->destination, AutoPingerInternal::AVAILABLE)) {
+
+                            // call external listener
+                            ctx->pingListener.DestinationFound(ctx->group, ctx->destination);
+                        }
+                    }
+                }
+
+            } else {
+                QCC_DbgPrintf(("AutoPingerInternal: ignoring callback - pinger not running"));
+            }
+            ctxs->erase(it);
+        } else {
+            QCC_DbgPrintf(("AutoPingerInternal: ignoring callback - ping already gone"));
+        }
+
+        ctxMutex->Unlock();
+
+        delete ctx;
+    }
+};
+
+static AutoPingAsyncCB* pingCallback = NULL;
+
+void AutoPingerInternal::Init()
+{
+    ctxs = new std::set<PingAsyncContext*>();
+    ctxMutex = new qcc::Mutex();
+    pingCallback = new AutoPingAsyncCB();
+}
+
+void AutoPingerInternal::Cleanup()
+{
+    delete ctxs;
+    ctxs = NULL;
+    delete ctxMutex;
+    ctxMutex = NULL;
+    delete pingCallback;
+    pingCallback = NULL;
+}
+
+AutoPingerInternal::AutoPingerInternal(ajn::BusAttachment& _busAttachment) :
+    timer("autopinger"), busAttachment(_busAttachment), pausing(false)
+{
+    QCC_DbgPrintf(("AutoPingerInternal constructed"));
+    timer.Start();
+}
+
+AutoPingerInternal::~AutoPingerInternal()
+{
+    pausing = true;
+    timer.RemoveAlarmsWithListener(*this);
+
+    // Stop timer thread
+    if (timer.IsRunning()) {
+        timer.Stop();
+    }
+
+    // Wait for thread to finish up
+    timer.Join();
+
+    // Invalidate all ctx;
+    ctxMutex->Lock();
+    for (std::set<PingAsyncContext*>::iterator it = ctxs->begin(); it != ctxs->end();) {
+        if ((*it)->pinger == this) {
+            ctxs->erase(it++);
+        } else {
+            it++;
+        }
+    }
+    ctxMutex->Unlock();
+
+    // Cleanup all groups
+    pingerMutex.Lock();
+    for (std::map<qcc::String, PingGroup*>::iterator pair = pingGroups.begin(); pair != pingGroups.end(); ++pair) {
+        delete pair->second;
+    }
+    pingerMutex.Unlock();
+
+    QCC_DbgPrintf(("AutoPingerInternal destructed"));
+}
+
+void AutoPingerInternal::AlarmTriggered(const qcc::Alarm& alarm, QStatus reason)
+{
+    qcc::String* groupName(reinterpret_cast<qcc::String*>(alarm->GetContext()));
+
+    if ((false == pausing) && (NULL != groupName)) {
+        // Ping all destination of the group
+        PingGroupDestinations(*groupName);
+    }
+}
+
+void AutoPingerInternal::PingGroupDestinations(const qcc::String& group)
+{
+    QCC_DbgPrintf(("AutoPingerInternal: start pinging destination in group: '%s'", group.c_str()));
+    ctxMutex->Lock();
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::const_iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        std::map<Destination, unsigned int>::iterator mapIt = (*it).second->destinations.begin();
+        for (; mapIt != (*it).second->destinations.end(); ++mapIt) {
+            PingAsyncContext* context = new PingAsyncContext(this, group, mapIt->first.destination, mapIt->first.oldState, (*it).second->pingListener);
+            std::pair<std::set<PingAsyncContext*>::iterator, bool> pair = ctxs->insert(context);
+            if (ER_OK != busAttachment.PingAsync(mapIt->first.destination.c_str(), PING_TIMEOUT, pingCallback, context)) {
+                ctxs->erase(pair.first);
+                delete context;
+            }
+        }
+    }
+    pingerMutex.Unlock();
+    ctxMutex->Unlock();
+}
+
+void AutoPingerInternal::Pause()
+{
+    // Stop all pending alarms
+    pausing = true;
+    timer.RemoveAlarmsWithListener(*this);
+
+    QCC_DbgPrintf(("AutoPingerInternal paused"));
+}
+
+void AutoPingerInternal::Resume()
+{
+    assert(timer.IsRunning());
+    if (true == pausing) {
+        pingerMutex.Lock();
+        // re-add all Alarm objects
+        std::map<qcc::String, PingGroup*>::const_iterator it = pingGroups.begin();
+        for (; it != pingGroups.end(); ++it) {
+            timer.AddAlarmNonBlocking((*it).second->alarm);
+        }
+        pingerMutex.Unlock();
+
+        pausing = false;
+        QCC_DbgPrintf(("AutoPingerInternal resumed"));
+    }
+}
+
+void AutoPingerInternal::AddPingGroup(const qcc::String& group, PingListener& listener, uint32_t pingInterval)
+{
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    uint32_t intervalMillisec = pingInterval * 1000;
+    if (it != pingGroups.end()) {
+        // Group already exists => just update its ping time
+        QCC_DbgPrintf(("AutoPingerInternal: updating existing group: '%s' with new ping time: %u", group.c_str(), pingInterval));
+
+        if (timer.RemoveAlarm((*it).second->alarm, false)) {
+            // Cleanup old alarm
+            void* context = (*it).second->alarm->GetContext();
+            (*it).second->alarm->SetContext(NULL);
+            if (NULL == context) {
+                // There was no context, create one
+                context = (void*)(new qcc::String(group));
+            }
+
+            // Alarm is a managed object (auto cleanup when overwritten)
+            qcc::AlarmListener* alarmListener = (qcc::AlarmListener*)this;
+            (*it).second->alarm = qcc::Alarm(intervalMillisec, alarmListener, context, intervalMillisec);
+            timer.AddAlarmNonBlocking((*it).second->alarm);
+        }
+    } else {
+        // Create a new group element
+        QCC_DbgPrintf(("AutoPingerInternal: adding new group: '%s' with ping time: %u", group.c_str(), pingInterval));
+
+        void* context = (void*)(new qcc::String(group));
+        PingGroup* pingGroup = new PingGroup(intervalMillisec, this, context, listener);
+        pingGroups.insert(std::pair<qcc::String, PingGroup*>(group, pingGroup));
+        timer.AddAlarmNonBlocking(pingGroup->alarm);
+    }
+    pingerMutex.Unlock();
+}
+
+void AutoPingerInternal::RemovePingGroup(const qcc::String& group)
+{
+    QCC_DbgPrintf(("AutoPingerInternal: removing group: '%s'", group.c_str()));
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        // destructor of PingGroup cleans-up context
+        timer.RemoveAlarm((*it).second->alarm, false);
+        delete it->second;
+        pingGroups.erase(it);
+    }
+    pingerMutex.Unlock();
+}
+
+QStatus AutoPingerInternal::SetPingInterval(const qcc::String& group, uint32_t pingInterval)
+{
+    QStatus status = ER_FAIL;
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        QCC_DbgPrintf(("AutoPingerInternal: updating group: '%s' with ping time: %u", group.c_str(), pingInterval));
+
+        if (timer.RemoveAlarm((*it).second->alarm, false)) {
+            // Cleanup old alarm
+            void* context = (*it).second->alarm->GetContext();
+            (*it).second->alarm->SetContext(NULL);
+            if (NULL == context) {
+                context = (void*)(new qcc::String(group));
+            }
+
+            // Alarm is a managed object (auto cleanup when overwritten)
+            uint32_t intervalMillisec = pingInterval * 1000;
+            qcc::AlarmListener* alarmListener = (qcc::AlarmListener*)this;
+            (*it).second->alarm = qcc::Alarm(intervalMillisec, alarmListener, context, intervalMillisec);
+            timer.AddAlarmNonBlocking((*it).second->alarm);
+
+            status = ER_OK;
+        }
+    } else {
+        status = ER_BUS_PING_GROUP_NOT_FOUND;
+        QCC_LogError(status, ("AutoPingerInternal: cannot update ping time for non-existing group: '%s'", group.c_str()));
+    }
+    pingerMutex.Unlock();
+    return status;
+}
+
+QStatus AutoPingerInternal::AddDestination(const qcc::String& group, const qcc::String& destination)
+{
+    QStatus status = ER_FAIL;
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        status = ER_OK;
+        Destination dummy(destination, AutoPingerInternal::UNKNOWN);
+        std::map<Destination, unsigned int>::iterator dit;
+        if ((dit = it->second->destinations.find(dummy)) == it->second->destinations.end()) {
+            QCC_DbgPrintf(("AutoPingerInternal: adding destination: '%s' to group: %s", destination.c_str(), group.c_str()));
+            (*it).second->destinations[(Destination(destination, AutoPingerInternal::UNKNOWN))] = 1;
+        } else {
+            dit->second++;
+            QCC_DbgPrintf(("AutoPingerInternal: destination: '%s' already present in group: %u; increasing refcount", destination.c_str(), group.c_str()));
+        }
+    } else {
+        status = ER_BUS_PING_GROUP_NOT_FOUND;
+        QCC_LogError(status, ("AutoPingerInternal: cannot add destination: '%s' to non-existing group: %u", destination.c_str(), group.c_str()));
+    }
+    pingerMutex.Unlock();
+
+    return status;
+}
+
+QStatus AutoPingerInternal::RemoveDestination(const qcc::String& group, const qcc::String& destination, bool removeAll)
+{
+    QStatus status = ER_FAIL;
+    QCC_DbgPrintf(("AutoPingerInternal: remove destination: '%s' from group: %s", destination.c_str(), group.c_str()));
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        status = ER_OK;
+        Destination dummy(destination, AutoPingerInternal::UNKNOWN);
+        std::map<Destination, unsigned int>::iterator dit = it->second->destinations.find(dummy);
+        if (dit != it->second->destinations.end()) {
+            if (removeAll == true) {
+                dit->second = 0;
+            } else {
+                --dit->second;
+            }
+
+            if (dit->second == 0) {
+                it->second->destinations.erase(dit);
+            }
+        }
+    }
+    pingerMutex.Unlock();
+
+    return status;
+}
+
+bool AutoPingerInternal::UpdatePingStateOfDestination(const qcc::String& group,
+                                                      const qcc::String& destination,
+                                                      const AutoPingerInternal::PingState state)
+{
+    QCC_DbgPrintf(("AutoPingerInternal: UpdatePingStateOfDestination: '%s' from group: %s", destination.c_str(), group.c_str()));
+    bool result = false;
+    pingerMutex.Lock();
+    std::map<qcc::String, PingGroup*>::iterator it = pingGroups.find(group);
+    if (it != pingGroups.end()) {
+        Destination dummy(destination, AutoPingerInternal::UNKNOWN);
+        std::map<Destination, unsigned int>::iterator dit = it->second->destinations.find(dummy);
+
+        // Update state
+        if (dit != (*it).second->destinations.end()) {
+            if (state != dit->first.oldState) {
+                /* this only works because oldState is mutable.
+                   Alternatively, you have to add it again to the map (and erase the old one) */
+                dit->first.oldState = state;
+                result = true; /* state gets updated */
+            }
+        }
+    }
+    pingerMutex.Unlock();
+    return result;
+}
+
+bool AutoPingerInternal::IsRunning()
+{
+    return timer.IsRunning();
+}
+
+}
diff --git a/alljoyn_core/src/AutoPingerInternal.h b/alljoyn_core/src/AutoPingerInternal.h
new file mode 100644
index 0000000..948707b
--- /dev/null
+++ b/alljoyn_core/src/AutoPingerInternal.h
@@ -0,0 +1,153 @@
+/**
+ * @file
+ *
+ * AutoPingerInternalInternal
+ */
+
+/******************************************************************************
+ * Copyright (c) 2015, AllSeen Alliance. All rights reserved.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ ******************************************************************************/
+
+#ifndef _ALLJOYN_AUTOPINGERINTERNAL_H_
+#define _ALLJOYN_AUTOPINGERINTERNAL_H_
+
+#ifndef __cplusplus
+#error Only include AutoPingerInternal.h in C++ code.
+#endif
+
+#include <map>
+#include <qcc/Timer.h>
+#include <qcc/String.h>
+#include <qcc/Mutex.h>
+#include <qcc/Debug.h>
+#include <alljoyn/Status.h>
+#include <alljoyn/PingListener.h>
+
+namespace ajn {
+/// @cond ALLJOYN_DEV
+/** @internal Forward references */
+struct PingGroup;
+class BusAttachment;
+/// @endcond
+
+/**
+ * AutoPingerInternal class
+ */
+class AutoPingerInternal : public qcc::AlarmListener {
+  public:
+    static void Init();
+    static void Cleanup();
+
+    /**
+     * Create instance of autopinger
+     *
+     */
+    AutoPingerInternal(BusAttachment& busAttachment);
+
+    /**
+     * Destructor
+     */
+    virtual ~AutoPingerInternal();
+
+    /**
+     * Pause all ping actions
+     */
+    void Pause();
+
+    /**
+     * Resume ping actions
+     */
+    void Resume();
+
+    /**
+     * Define new ping group
+     *
+     * @param  group Ping group name
+     * @param  listener Listener called when a change was detected in the reachability of a destination
+     * @param  pingInterval Ping interval in seconds
+     */
+    void AddPingGroup(const qcc::String& group, PingListener& listener, uint32_t pingInterval = 5);
+
+    /**
+     * Remove complete ping group, including all destinations
+     *
+     * @param  group Ping group name
+     */
+    void RemovePingGroup(const qcc::String& group);
+
+    /**
+     * Set ping interval of the specified group
+     *
+     * @param  group Ping group name
+     * @param  pingInterval Ping interval in seconds
+     * @return
+     *  - #ER_OK: Interval updated
+     *  - #ER_BUS_PING_GROUP_NOT_FOUND: group did not exist
+     */
+    QStatus SetPingInterval(const qcc::String& group, uint32_t pingInterval);
+
+    /**
+     * Add a destination to the specified ping group
+     * Destinations are refcounted and must be removed N times if they were added N times
+     *
+     * @param  group Ping group name
+     * @param  destination Destination name to be pinged
+     * @return
+     *  - #ER_OK: destination added
+     *  - #ER_BUS_PING_GROUP_NOT_FOUND: group did not exist
+     */
+    QStatus AddDestination(const qcc::String& group, const qcc::String& destination);
+
+    /**
+     * Remove a destination from the specified ping group
+     * This will lower the refcount by one and only remove the destination when the refcount reaches zero
+     *
+     * @param  group Ping group name
+     * @param  destination Destination name to be removed
+     * @param  removeAll Rather than decrementing the refcount by one, set refcount to zero and remove
+     * @return
+     *  - #ER_OK: destination removed or was not present
+     *  - #ER_BUS_PING_GROUP_NOT_FOUND: group did not exist
+     */
+    QStatus RemoveDestination(const qcc::String& group, const qcc::String& destination, bool removeAll = false);
+
+  private:
+    friend class AutoPingAsyncCB;
+    friend struct Destination;
+    friend class PingAsyncContext;
+
+    enum PingState {
+        UNKNOWN,
+        LOST,
+        AVAILABLE
+    };
+
+    AutoPingerInternal(const AutoPingerInternal&);
+    void operator=(const AutoPingerInternal&);
+
+    bool UpdatePingStateOfDestination(const qcc::String& group, const qcc::String& destination, const AutoPingerInternal::PingState state);
+    void PingGroupDestinations(const qcc::String& group);
+    bool IsRunning();
+    void AlarmTriggered(const qcc::Alarm& alarm, QStatus reason);
+
+    qcc::Timer timer; /* Single Timerthread */
+    BusAttachment& busAttachment;
+    qcc::Mutex pingerMutex;
+    std::map<qcc::String, PingGroup*> pingGroups;
+
+    bool pausing;
+};
+}
+#endif /* AUTOPINGERINTERNAL_H_ */
diff --git a/alljoyn_core/unit_test/AutoPingerTest.cc b/alljoyn_core/unit_test/AutoPingerTest.cc
index 949b7a0..477d795 100644
--- a/alljoyn_core/unit_test/AutoPingerTest.cc
+++ b/alljoyn_core/unit_test/AutoPingerTest.cc
@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright (c) 2014, AllSeen Alliance. All rights reserved.
+ * Copyright (c) 2014,2015, AllSeen Alliance. All rights reserved.
  *
  *    Permission to use, copy, modify, and/or distribute this software for any
  *    purpose with or without fee is hereby granted, provided that the above
@@ -16,6 +16,9 @@
 #include <alljoyn/BusAttachment.h>
 #include <alljoyn/AutoPinger.h>
 #include <gtest/gtest.h>
+#include <qcc/Thread.h>
+
+#include "ajTestCommon.h"
 
 using namespace ajn;
 
@@ -29,10 +32,10 @@ class AutoPingerTest : public testing::Test {
     virtual void SetUp() {
         QStatus status = ER_OK;
         status = serviceBus.Start();
-        ASSERT_EQ(ER_OK, status) << "  Actual Status: " << QCC_StatusText(status);
+        ASSERT_EQ(ER_OK, status);
         ASSERT_FALSE(serviceBus.IsConnected());
         status = serviceBus.Connect();
-        ASSERT_EQ(ER_OK, status) << "  Actual Status: " << QCC_StatusText(status);
+        ASSERT_EQ(ER_OK, status);
         ASSERT_TRUE(serviceBus.IsConnected());
     }
 
